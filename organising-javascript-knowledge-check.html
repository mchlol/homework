<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Knowledge Check - Organising JavaScript Code</title>

    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="icon" href="./homework.ico">

</head>


<body>

    <nav id="nav">
        <ul>
            <li><a class="home-link" href="index.html">Home</a></li>
            <li><a href="#constructors">Objects and Object Constructors</a></li>
            <li><a href="#factory">Factory Functions & The Module Pattern</a></li>
            <li><a href="#classes">JavaScript Classes</a></li>
            <li><a href="#modules">ES6 Modules</a></li>
        </ul>
    </nav>

    <div>
        <a href="#nav"><button class="top-btn"><span class="material-icons">
                    arrow_upward
                </span></button></a>
    </div>

    <div id="header" class="container">
        <h1 id="top">Knowledge Check - Full-stack JavaScript</h1>
        <p>Homework for <a href="https://www.theodinproject.com">The Odin Project</a></p>
    </div>

    <main id="answers" class="container">
        <hr>

        <section id="constructors">
            <h2>Objects and Object Constructors</h2>

            <h3>Write an object constructor and instantiate the object.</h3>
            <pre>
            <code>
                // object constructor:
            function Cat(name, sound) {
                this.name = name,
                this.sound = sound
            }
            
                // instantiate the object
            const fluffy = new Cat('Fluffy', 'miaow!');
            </code>
            </pre>

            <h3>Describe what a prototype is and how it can be used.</h3>
            <p>
                A prototype is a property that exists by default on any JavaScript function (all functions are objects).
                Add methods onto this
                prototype, and they can be used by any object created using the function as a constructor; such objects
                are also known as <strong>instances</strong>.</p>

            <h3>Explain prototypal inheritance.</h3>
            <p>When an object is created with a constructor, it will inherit any properties and methods from its parent
                object, which in turn inherits these from its parent and so on back to
                <code>Object.prototype</code>.<br>
                When a lookup is performed on an object, it will look
                first on that object, and if the property is not found, the search will continues on that objects
                prototype, and so on up
                the chain until the property is found.
            </p>

            <h3>What are the basic dos and don'ts of prototypical inheritance?</h3>
            <p><strong>Don't</strong> define a function directly on an object constructor - unless you want it to be
                available only on
                that object. Defining it on the prototype means only defining it once, and not creating multiples of
                the same function every time a new object is created.<br>
                <strong>Do</strong> use an objects prototype to define functions. This is so they can be used by all
                instances of that
                object,
                and the function only needs to be defined once. This will keep your files smaller and help you to write
                clean code.
            </p>

            <h3>Explain what Object.create does.</h3>
            <p><code>Object.create(obj)</code> creates an object, where <code>obj</code> is the object you would like to
                inherit
                properties from.</p>

            <h4>Notes</h4>
            <ul>
                <li>Any object can only have ONE prototype and can only inherit from ONE object prototype at a
                    time.</li>
                <li>Arrow functions do not have a <code>this</code> keyword or a prototype property so cannot be used as
                    constructor functions.</li>
            </ul>


        </section>

        <hr>

        <section id="factory">
            <h2>Factory Functions & The Module Pattern</h2>
            <small>Further info found at <a href="https://css-tricks.com/understanding-javascript-constructors/"
                    target="_blank">CSS Tricks</a></small>

            <h3>Describe common bugs you might run into using constructors.</h3>
            <p>
            <ul>
                <li>If you forget to use the <code>new</code> keyword, you will actually be setting properties on the
                    global object.</li>
                <li>If you return something from the constructor function, an object created by using <code>new</code>
                    will reference whatever the constructor returned, instead of creating a new instance of the
                    constructor.</li>
            </ul>
            </p>

            <h3>Write a factory method that returns an object.</h3>
            <p>A factory function is just a <strong>function that returns an object</strong>. It does not need to use
                the <code>new</code> or <code>this</code> keywords. It is in a way a lot simpler and neater than using
                constructors.
            <pre>
    <code>const dogMaker = (name,breed) => {
                const bark = () => console.log("Woof");
                return { name, breed, bark };
            }

            const oslow = dogMaker("Oslow","Golden Retriever");
            
            console.log(oslow) // { name: "Oslow", breed: "Golden Retriever" }

     </code>
</pre>
            </p>

            <h3>Explain how scope works in JavaScript (bonus points if you can point out what ES6 changed!).</h3>
            <p>
                In JavaScript, variables that are declared globally are accessible within the global objects including
                any functions,
                loops, etc. Variables that are declared within a function are only accessible <strong>within that
                    function</strong>, or if declared within a block they are only accessible within that block - they
                cannot be accessed globally or within other functions.<br>
                Variables declared with <code>var</code> are <strong>function scoped</strong>, but the new variable
                declaration methods introduced in ES6, <code>let</code> and <code>const</code> are <strong>block
                    scoped</strong>. This means that if you use var in a loop, the var variable will end up globally
                scopes as there's no function. A let or const variable will be scoped to the block, meaning if it's
                declared within a function or any kind of loop, it will remain confined to that block and is not
                accessible in the global object or anywhere but in that block.
            </p>

            <h3>Explain what Closure is and how it impacts private functions & variables.</h3>
            <p>
                When a function, like a constructor, contains some other functions and returns one of them, only the
                returned function can be called. Any other function defined within that constructor is
                <strong>private</strong>. They remain confined to the block they were defined in (the constructor).
                However, the <em>returned</em> function can still access them. That is because it has
                <strong>closure</strong> over them.
            </p>

            <pre>
    <code>
    const dogMaker = (name) => {
        const bark = () => console.log("Woof!");
        const speak = () => bark();
        const beCute = () => console.log(`Aww ${name} is so cute!`);
        return { name, speak, beCute };
    }
                
    const oslow = dogMaker("Oslow");

    oslow.bark() // returns a type error
                
    oslow.speak() // "Woof!"

    </code>
</pre>

            <p>
                The <code>dogMaker</code> factory function makes an object that has a private function
                <code>bark()</code>
                which cannot be called, because it is <strong>scoped</strong> to the <code>dogMaker</code>
                factory function.<br>
                However <code>dogMaker</code> does return a <strong>public</strong> function <code>speak</code> which
                has
                <strong>closure</strong> over the <code>bark()</code> function, so when we call
                <code>oslow.speak()</code>
                it can access the <code>bark()</code> function and return its value.
            </p>



            <figure>
                <blockquote
                    cite="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36">
                    "Not only should you know what a closure is, you should know why it matters, and be able to
                    easily answer several possible use-cases for closures."</blockquote>
                <figcaption>
                    &mdash; Eric Elliot, <cite><a
                            href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36"
                            target="_blank">Master the JavaScript Interview: What is a Closure?</a></cite>
                </figcaption>
            </figure>

            <h3>Describe how private functions & variables are useful.</h3>
            <p>
                Private variables and functions are useful because instead of having a bunch of variables accessible all
                over your
                global object, you can just have a few functions that contain your variables which protects them from
                being accessed or overwritten, and keeps things neat and tidy. It makes your code easier to read, and
                easier to refactor where required.
            </p>

            <h3>Use inheritance in objects using the factory pattern.</h3>
            <p>
                We can use inheritance inside a factory function by creating a new variable with a factory function, and
                use destructuring syntax to inherit a property or function from the factory.<br>
                In our <code>dogMaker</code> factory function we return a <code>beCute</code>
                function:</p>

            <pre>
<code>
    const dogMaker = (name) => {
        const bark = () => console.log("Woof!");
        const speak = () => bark();
        const beCute = () => console.log(`Aww ${name} is so cute!`);
        return { name, speak, beCute };
    }

    const catMaker = (name) => {
        const { beCute } = dogMaker(name);
        return { name, beCute };
    }

    </code>
</pre>

            <p>
                We already have a <code>beCute</code> function on <code>dogMaker</code>, so we don't have to make a new
                one for <code>catMaker</code>. We can
                just inherit it.<br>
                Using <a
                    href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment"
                    target="_blank">destructuring syntax</a>, we can create a variable in <code>catMaker</code> and call
                the <code>beCute</code> function from <code>dogMaker</code>. Remember <code>dogMaker</code>
                <strong>returns</strong> this function, so unlike <code>bark()</code>, we can access it.
            <pre>
    <code>const molly = cat("Molly");
    molly.beCute() // "Aww, Molly is so cute!"</code>
</pre>

            <p>
                If we wanted to inherit <em>everything</em> from an object we could do that with
                <code>Object.assign()</code>. All own and enumerable
                properties will be copied to the new object. It takes two arguments: target and source.
            </p>
            <pre>
    <code>
        const pandy = Object.assign({}, oslow);

        pandy.speak() // Woof!
    </code>
</pre>



            <figure>
                <blockquote>
                    "Note that the Object.assign() only carries a shallow clone, not a deep clone."
                </blockquote>
                <figcaption>
                    &mdash; JavaScript Tutorial, <cite><a
                            href="https://www.javascripttutorial.net/es6/javascript-object-assign/"
                            target="_blank">JavaScript Object.assign()</a></cite>
                </figcaption>
            </figure>

            <h3>Explain the module pattern.</h3>
            <p>
                In the JavaScript module pattern, we create a function expression and within that block of code we add
                all the variables and functions needed.
                This encapsulates all the code within its own scope, so we don't affect the global namespace.<br>
                If we have
                a
                function inside this scope called 'add' and then need to use the name 'add' in a difference context,
                e.g. add to cart and add two numbers together, as long as they are within separate scopes they will not
                clash with each other and cause bugs.<br>
                We then invoke the function as an IIFE (see below) so that we can run it straightaway and can access
                whatever we need from this function without having to call it multiple times (or at all).
            </p>

            <h3>Describe IIFE. What does it stand for?</h3>
            <p>Immediately Invoked Function Expression, or IIFE, is when you write a function and immediately call or
                invoke it. In other words, the function runs as soon as it is assigned. </p>
            <pre>
    <code>
    const normalFunction = function() {
        console.log('This function has to be invoked')
    }
                
    normalFunction(); // invoking the function
                
    const iifeFunction = (function() {
        console.log('This function is invoked immediately!')
    })();
                
    // we don't have to call iifeFunction(), it already ran!
</code>
</pre>

            <h3>Briefly explain namespacing and how it's useful.</h3>
            <p>
                Namespacing is the technique of enscapulating variable and function names within their own scopes
                instead of on the global object. This prevents possible bugs with names being used multiple times, and
                keeps variables private where possible.
            </p>

        </section>

        <section>
            <h2 id="classes">JavaScript Classes</h2>

            <h3>Describe the pros and cons of using classes in JavaScript.</h3>

            <ul>
                <h4>Pros:</h4>
                <li>
                    Classes make it easier to create multiple objects sharing the same methods without having to add
                    them to the prototype separately. This shorter syntax means cleaner code.
                </li>
                <li>
                    Unlike with a constructor function, if you try to call a class without the new keyword you will
                    actually get
                    a <code>TypeError</code> which will help avoid bugs.
                </li>
            </ul>

            <ul>
                <h4>Cons:</h4>
                <li>
                    While classes are hoisted, like functions, their values are not initialised. So they cannot be
                    referenced before they are
                    declared.
                </li>
                <li>Class methods are non-enumerable so can't be accessed in a for…in loop or Object.keys() method.</li>
            </ul>

            <figure>
                <blockquote>
                    "A common pitfall for novice developers is to put a comma between class methods, which would result
                    in a syntax error.<br>
                    The notation here is not to be confused with object literals. Within the class, no commas are
                    required."
                </blockquote>
                <figcaption>&mdash; JavaScript.info, <cite><a href="https://javascript.info/class"
                            target="_blank">Classes</a></cite>
                </figcaption>
            </figure>

            <h3>Briefly discuss how JavaScript's object creation differs from a language like Java or Ruby.</h3>
            <p>
                In Java and Ruby, all
                objects are instances of a class. In JavaScript, you can just create an object, e.g. by using an object
                literal.
            </p>

            <h3>Explain the differences between using a class to define a constructor and other prototype methods.</h3>
            <p>
                Classes are <em>syntactic sugar</em> over constructor functions, with some added enhancements.
            </p>
            <h4>Object constructor:</h4>
            <pre>
            <code>
                const Animal = function(name, sound) {
                    this.name = name,
                    this.sound = sound
                    this.speak = function() {
                        console.log(this.sound);
                    }
                }
            </code>
            </pre>

            <h4>Factory function:</h4>
            <pre>
            <code>
                const Animal = (name, sound) => {
                    const speak = () => console.log(sound);
                    return { name, sound, speak };
                }
            </code>
            </pre>

            <h4>Class:</h4>
            <pre>
            <code>
                class Animal {
                    name;
                    constructor(name,sound) {
                        this.name = name;
                        this.sound = sound;
                    }

                    speak() {
                        console.log(this.sound);
                    }
                }
            </code>
            </pre>
            <p>The biggest difference is in when they are called. Both are
                called with <code>new Animal</code>, right? But if you call a class without <code>new</code>, you'll get
                a <code>TypeError</code>. Object constructors and factory functions don't do that, making it much easier
                to introduce
                bugs into your code.</p>

            <h3>Explain what “getters” & “setters” are.</h3>
            <p>
                Getters and setters are accessor properties that set and get the values of an object. A getter
                returns the value, a setter defines the value. A getter cannot be used without a setter.
            </p>

            <h3>Understand what computed names and class fields are.</h3>
            <h4>Computed Names</h4>
            <p>Computed names are expressions within square brackets that can be evaluated to use as variable names.<br>
                If we have an expression within brackets <code>['say' + 'Hi'()]</code>, at run time the property name
                will be <code>sayHi()</code>.</p>
            <h4>Class Fields</h4>
            <p>
                Class fields are another way to add properties to the class. Declaring fields can be easier to read than
                defining properties in the constructor.
            </p>

            <h3>Describe function binding.</h3>
            <p>
                Function binding is a way of ensuring <code>this</code> always refers to the object and is not lost or
                assigned to somethng else (often the window object) when
                the functin is called in another context.
            </p>

            <h3>Be able to use inheritance with classes.</h3>
            <p>
                To create a class that inherits properties and methods from another class, it must be called with
                <code>extends</code> and then the properties are accessed through <code>super</code>.
            </p>
            <pre>
<code>
<span class="syntax-comment">// create a class with constructor and a method</span>
    class Animal {
        constructor(name) {
            this.name = name;
        }
        
        speak() {
            console.log(`${this.name} makes a noise.`);
        }
    }

<span class="syntax-comment">// create a new class that extends the class we want to inherit from</span>
    class Dog <span class="syntax-highlight">extends</span> Animal {
        constructor(name) {
            <span class="syntax-comment">// call the super class constructor and pass in the name parameter</span>
            <span class="syntax-highlight">super</span>(name);
        }

        speak() {
            <span class="syntax-comment">// we can use super here too</span>
            super.speak();
            console.log(`${this.name} barks.`);
        }
    }
</code>
            </pre>
            <p>Using super in the subclass method means the original inherited function will run first, then any new
                method that has been changed on the subclass.</p>
            <figure>
                <blockquote>"If there is a constructor in the subclass it has to call <code>super</code> before using
                    <code>this</code>."
                </blockquote>
                <figcaption>
                    MDN Web Docs, <cite><a
                            href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#sub_classing_with_extends"
                            target="_blank">Classes</a></cite>
                </figcaption>
            </figure>

            <p> To inherit from a regular object we cannot use <code>extends</code>, but we can create the class and
                then use
                <code>Object.setPrototypeOf()</code>.
            </p>

            <h3>Briefly talk about the conflict in JS with functional programming and classes.</h3>
            <p>
                JavaScript is a functional programming language, and it doesn't technically include classes like object
                oriented
                programming languages do. The class syntax was developed to make it more familiar for developers coming
                from OOP languages to work with. The conflict is that functional programming favours composition over
                inheritance -
                but OOP favours inheritance over composition.
            </p>
        </section>

        <section>
            <h2 id="modules">ES6 Modules</h2>

            <h3>Explain what npm is and where it was commonly used before being adopted on the frontend.</h3>
            <p>
                npm, or node package manager, is used to install packages such as javascript and css libraries into your
                project, without having to download and manually link them.<br>
                It was originally used for node, an environment that can run JavaScript outside of a web browser.
            </p>

            <h3>Describe what <code>npm init</code> does and what <code>package.json</code> is.</h3>
            <p>
                <code>npm init</code> initialises npm; on the command line it prompts you to fill in some information
                about your project and then creates a node_modules folder to access the library, and a
                <code>package.json</code> file. The
                <code>package.json</code> keeps track of any dependencies (such as libraries) in use within your
                project.
            </p>


            <h3>Know how to install packages using npm.</h3>
            <p>
                First, navigate to your project folder on the command line and run <code>npm init</code>.<br>
                Then run
                <code>npm install &lt;package name&gt; --save</code>. This will download the package into the
                <code>node_modules</code> folder and creates your <code>package.json</code> file.<br>
                npm can be used to install TypeScript React, Tailwind, Sass, and all sorts of libraries and tools.
            </p>

            <h3>Describe what a JavaScript module bundler like webpack is.</h3>
            <p>
                Webpack works by importing modules of code into your project. Node has access to the computer's file
                system, so running webpack will build one file with
                all the modules needed, and you can just link that file, without having to find and link all the
                libraries and things you need manually.
            </p>

            <h3>Explain what the concepts “entry” and “output” mean as relates to webpack.</h3>
            <p>
                The "entry" is the file in which <strong>we write</strong> our JavaScript and link any modules we want
                to use. The
                "output" is the file <strong>built by webpack</strong> when it is run. This is the file we link as the
                <code>src</code> in our
                project.
            </p>

            <h3>Briefly explain what a development dependency is.</h3>
            <p>
                A development dependency is a library or module that we reference and use in the js or css file we
                write. We can't just link that file, because it will contain things the browser can't find or interpret.
                A bundler, like webpack, bundles all the dependencies into the file it builds. Dependencies have to be
                included in the <code>package.json</code> file or they won't work.<br>
                Production dependencies go under <code>dependencies</code> and
                development dependencies such as testing and linting go in <code>devDependencies</code>.
            </p>

            <h3>Explain what “transpiling code” means and how it relates to frontend development.</h3>
            <p>
                Transpiling converts code from one language into another similar language. When we run Webpack we can
                use Babel to transpile our JavaScript to ES5 (an older version of JavaScript) so any new features we are
                using can still be understood by
                out of
                date browsers.
            </p>

            <h3>Briefly describe what a task runner is and how it's used in frontend development.</h3>
            <p>
                A task runner is a script we run to automate a process, such as transpiling and building js and css
                files or running tests.
            </p>

            <h3>Describe how to write an npm automation script.</h3>
            <p>
                In the "scripts" section of your <code>package.json</code> file, you can list any automation scripts
                such as;<br>
                <code>"build": "webpack --progress --mode=production</code><br>
                Then in the terminal run <code>$ npm run build</code> to run webpack and show the percent progress. The
                <code>--mode=production</code> minimises the code for production. Then to actually run the script go to
                the terminal and run <code>npm run build</code>.
            </p>

            <h3>Explain one of the main benefits of writing code in modules.</h3>
            <p>
                <span class="temp">Reusing code, separating code, private variables</span>
            </p>

            <h3>Explain “named exports” and “default exports”.</h3>
            <p>
                <strong>Default exports</strong> can be exported one at a time, if you have multiple functions in one
                file you can specifically export
                them at the same time by using <strong>named exports</strong>.
            </p>
        </section>
    </main>

    <script>
        // example of factory functions

        const dogMaker = (name) => {
            const bark = () => console.log("Woof!");
            const speak = () => bark();
            const beCute = () => console.log(`Aww ${name} is so cute!`);
            return { name, speak, beCute };
        }

        const oslow = dogMaker("Oslow");

        const catMaker = (name) => {
            const { beCute } = dogMaker(name);
            return { name, beCute };
        }

        const molly = catMaker("Molly");

        const pandy = Object.assign({}, oslow);


        // different constructor & prototype methods

        const AnimalConstructor = function (name, sound) {
            this.name = name,
                this.sound = sound,

                // add a method
                this.speak = function () {
                    console.log(this.sound);
                }
        }

        const AnimalFactory = (name, sound) => {
            // add a method
            const speak = () => console.log(sound);
            return { name, sound, speak };
        }

        class AnimalClass {
            // initialise properties
            constructor(name, sound) {
                this.name = name;
                this.sound = sound;
            }

            // add a method
            speak() {
                console.log(this.sound);
            }
        }
    </script>
</body>

</html>